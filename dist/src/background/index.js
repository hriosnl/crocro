var V=Object.defineProperty;var K=(C,S,R)=>S in C?V(C,S,{enumerable:!0,configurable:!0,writable:!0,value:R}):C[S]=R;var m=(C,S,R)=>K(C,typeof S!="symbol"?S+"":S,R);(function(){"use strict";var C=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function S(y){return y&&y.__esModule&&Object.prototype.hasOwnProperty.call(y,"default")?y.default:y}var R={exports:{}};(function(y,e){(function(s,n){n(y)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:C,function(s){var n,r;if(!((r=(n=globalThis.chrome)==null?void 0:n.runtime)!=null&&r.id))throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const a="The message port closed before a response was received.",o=d=>{const u={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(u).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class b extends WeakMap{constructor(i,c=void 0){super(c),this.createItem=i}get(i){return this.has(i)||this.set(i,this.createItem(i)),super.get(i)}}const I=t=>t&&typeof t=="object"&&typeof t.then=="function",P=(t,i)=>(...c)=>{d.runtime.lastError?t.reject(new Error(d.runtime.lastError.message)):i.singleCallbackArg||c.length<=1&&i.singleCallbackArg!==!1?t.resolve(c[0]):t.resolve(c)},k=t=>t==1?"argument":"arguments",z=(t,i)=>function(l,...h){if(h.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${k(i.minArgs)} for ${t}(), got ${h.length}`);if(h.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${k(i.maxArgs)} for ${t}(), got ${h.length}`);return new Promise((p,f)=>{if(i.fallbackToNoCallback)try{l[t](...h,P({resolve:p,reject:f},i))}catch(g){console.warn(`${t} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,g),l[t](...h),i.fallbackToNoCallback=!1,i.noCallback=!0,p()}else i.noCallback?(l[t](...h),p()):l[t](...h,P({resolve:p,reject:f},i))})},D=(t,i,c)=>new Proxy(i,{apply(l,h,p){return c.call(h,t,...p)}});let T=Function.call.bind(Object.prototype.hasOwnProperty);const N=(t,i={},c={})=>{let l=Object.create(null),h={has(f,g){return g in t||g in l},get(f,g,x){if(g in l)return l[g];if(!(g in t))return;let A=t[g];if(typeof A=="function")if(typeof i[g]=="function")A=D(t,t[g],i[g]);else if(T(c,g)){let E=z(g,c[g]);A=D(t,t[g],E)}else A=A.bind(t);else if(typeof A=="object"&&A!==null&&(T(i,g)||T(c,g)))A=N(A,i[g],c[g]);else if(T(c,"*"))A=N(A,i[g],c["*"]);else return Object.defineProperty(l,g,{configurable:!0,enumerable:!0,get(){return t[g]},set(E){t[g]=E}}),A;return l[g]=A,A},set(f,g,x,A){return g in l?l[g]=x:t[g]=x,!0},defineProperty(f,g,x){return Reflect.defineProperty(l,g,x)},deleteProperty(f,g){return Reflect.deleteProperty(l,g)}},p=Object.create(t);return new Proxy(p,h)},j=t=>({addListener(i,c,...l){i.addListener(t.get(c),...l)},hasListener(i,c){return i.hasListener(t.get(c))},removeListener(i,c){i.removeListener(t.get(c))}}),W=new b(t=>typeof t!="function"?t:function(c){const l=N(c,{},{getContent:{minArgs:0,maxArgs:0}});t(l)}),L=new b(t=>typeof t!="function"?t:function(c,l,h){let p=!1,f,g=new Promise(M=>{f=function(w){p=!0,M(w)}}),x;try{x=t(c,l,f)}catch(M){x=Promise.reject(M)}const A=x!==!0&&I(x);if(x!==!0&&!A&&!p)return!1;const E=M=>{M.then(w=>{h(w)},w=>{let O;w&&(w instanceof Error||typeof w.message=="string")?O=w.message:O="An unexpected error occurred",h({__mozWebExtensionPolyfillReject__:!0,message:O})}).catch(w=>{console.error("Failed to send onMessage rejected reply",w)})};return E(A?x:g),!0}),$=({reject:t,resolve:i},c)=>{d.runtime.lastError?d.runtime.lastError.message===a?i():t(new Error(d.runtime.lastError.message)):c&&c.__mozWebExtensionPolyfillReject__?t(new Error(c.message)):i(c)},q=(t,i,c,...l)=>{if(l.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${k(i.minArgs)} for ${t}(), got ${l.length}`);if(l.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${k(i.maxArgs)} for ${t}(), got ${l.length}`);return new Promise((h,p)=>{const f=$.bind(null,{resolve:h,reject:p});l.push(f),c.sendMessage(...l)})},H={devtools:{network:{onRequestFinished:j(W)}},runtime:{onMessage:j(L),onMessageExternal:j(L),sendMessage:q.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:q.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},_={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return u.privacy={network:{"*":_},services:{"*":_},websites:{"*":_}},N(d,H,u)};s.exports=o(chrome)}else s.exports=globalThis.browser})})(R);var G=R.exports;const v=S(G);class F{constructor(e){m(this,"ws",null);m(this,"url");m(this,"reconnectAttempts",0);m(this,"maxReconnectAttempts",5);m(this,"reconnectDelay",1e3);m(this,"isConnected",!1);m(this,"currentRoomId",null);m(this,"keepAliveInterval",null);m(this,"onSignal",null);m(this,"onMessage",null);m(this,"onConnected",null);m(this,"onDisconnected",null);m(this,"onError",null);m(this,"signalHandlers",new Set);this.url=e}async connect(){return new Promise((e,s)=>{try{this.ws=new WebSocket(this.url),this.ws.onopen=()=>{var n;console.log("Signaling client connected"),this.isConnected=!0,this.reconnectAttempts=0,this.startKeepAlive(),(n=this.onConnected)==null||n.call(this),e()},this.ws.onmessage=n=>{try{const r=JSON.parse(n.data);this.handleSignalMessage(r)}catch(r){console.error("Failed to parse signaling message:",r)}},this.ws.onclose=n=>{var r;console.log("Signaling connection closed:",n.code,n.reason),this.isConnected=!1,(r=this.onDisconnected)==null||r.call(this),!n.wasClean&&this.reconnectAttempts<this.maxReconnectAttempts?(console.log("Connection closed unexpectedly, scheduling reconnect..."),this.scheduleReconnect()):n.wasClean?console.log("Connection closed cleanly"):console.log("Max reconnect attempts reached")},this.ws.onerror=n=>{var a;console.error("Signaling connection error:",n);const r="WebSocket connection failed";(a=this.onError)==null||a.call(this,r),s(new Error(r))}}catch(n){s(n)}})}disconnect(){this.stopKeepAlive(),this.ws&&(this.ws.close(1e3,"Normal closure"),this.ws=null),this.isConnected=!1,this.currentRoomId=null}startKeepAlive(){this.stopKeepAlive(),this.keepAliveInterval=setInterval(()=>{var e;this.isConnected&&((e=this.ws)==null?void 0:e.readyState)===WebSocket.OPEN&&this.sendMessage({type:"ping"})},3e4)}stopKeepAlive(){this.keepAliveInterval&&(clearInterval(this.keepAliveInterval),this.keepAliveInterval=null)}async createRoom(){return new Promise((e,s)=>{if(!this.isConnected){s(new Error("Not connected to signaling server"));return}const n=this.generateRoomId(),r=a=>{var o;a.type==="room-created"&&a.roomId===n?(this.currentRoomId=n,this.removeSignalHandler(r),e(n)):a.type==="error"&&a.roomId===n&&(this.removeSignalHandler(r),s(new Error(((o=a.data)==null?void 0:o.message)||"Failed to create room")))};this.addSignalHandler(r),this.sendMessage({type:"create-room",roomId:n})})}async joinRoom(e){return new Promise((s,n)=>{if(!this.isConnected){n(new Error("Not connected to signaling server"));return}const r=a=>{var o;a.type==="room-joined"&&a.roomId===e?(this.currentRoomId=e,this.removeSignalHandler(r),s()):a.type==="error"&&a.roomId===e&&(this.removeSignalHandler(r),n(new Error(((o=a.data)==null?void 0:o.message)||"Failed to join room")))};this.addSignalHandler(r),this.sendMessage({type:"join-room",roomId:e})})}sendSignal(e){if(!this.isConnected||!this.currentRoomId){console.warn("Cannot send signal: not connected or no active room");return}this.sendMessage({type:"signal",roomId:this.currentRoomId,data:e})}sendRelayMessage(e){if(!this.isConnected||!this.currentRoomId){console.warn("Cannot send relay message: not connected or no active room");return}this.sendMessage({type:"relay-message",roomId:this.currentRoomId,data:e})}handleSignalMessage(e){var s,n,r,a,o;switch(console.log("Received signaling message:",e.type,e),e.type){case"offer":case"answer":case"ice-candidate":(s=this.onSignal)==null||s.call(this,e);break;case"peer-joined":console.log("Peer joined room:",e.peerId),(n=this.onSignal)==null||n.call(this,{type:"peer-joined",peerId:e.peerId});break;case"peer-left":console.log("Peer left room:",e.peerId),(r=this.onSignal)==null||r.call(this,{type:"peer-left",peerId:e.peerId});break;case"peer-reconnected":console.log("Peer reconnected:",e.peerId),(a=this.onSignal)==null||a.call(this,e);break;case"relay-message":console.log("Received relay message from peer:",e.peerId),(o=this.onMessage)==null||o.call(this,e.data);break;default:this.signalHandlers.forEach(d=>d(e))}}addSignalHandler(e){this.signalHandlers.add(e)}removeSignalHandler(e){this.signalHandlers.delete(e)}sendMessage(e){this.ws&&this.ws.readyState===WebSocket.OPEN?this.ws.send(JSON.stringify(e)):console.warn("Cannot send message: WebSocket not open")}scheduleReconnect(){this.reconnectAttempts++;const e=this.reconnectDelay*Math.pow(2,this.reconnectAttempts-1);console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${e}ms`),setTimeout(()=>{this.isConnected||this.connect().catch(s=>{console.error("Reconnect failed:",s)})},e)}generateRoomId(){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";let s="";for(let n=0;n<6;n++)s+=e.charAt(Math.floor(Math.random()*e.length));return s}getConnectionState(){if(!this.ws)return"disconnected";switch(this.ws.readyState){case WebSocket.CONNECTING:return"connecting";case WebSocket.OPEN:return"connected";default:return"disconnected"}}}class B{constructor(){m(this,"db",null);m(this,"dbName","CrocroChat");m(this,"dbVersion",1)}async initialize(){return new Promise((e,s)=>{const n=indexedDB.open(this.dbName,this.dbVersion);n.onerror=()=>s(n.error),n.onsuccess=()=>{this.db=n.result,e()},n.onupgradeneeded=r=>{const a=r.target.result;if(!a.objectStoreNames.contains("messages")){const o=a.createObjectStore("messages",{keyPath:"id"});o.createIndex("roomId","roomId",{unique:!1}),o.createIndex("timestamp","timestamp",{unique:!1})}a.objectStoreNames.contains("sessions")||a.createObjectStore("sessions",{keyPath:"roomId"}).createIndex("createdAt","createdAt",{unique:!1}),a.objectStoreNames.contains("profiles")||a.createObjectStore("profiles",{keyPath:"id"})}})}async saveMessage(e){return this.db||await this.initialize(),new Promise((s,n)=>{const o=this.db.transaction(["messages"],"readwrite").objectStore("messages").put(e);o.onerror=()=>n(o.error),o.onsuccess=()=>s()})}async getMessages(e,s=100){return this.db||await this.initialize(),new Promise((n,r)=>{const u=this.db.transaction(["messages"],"readonly").objectStore("messages").index("roomId").getAll(e);u.onerror=()=>r(u.error),u.onsuccess=()=>{const b=u.result.sort((I,P)=>I.timestamp-P.timestamp).slice(-s);n(b)}})}async updateMessageStatus(e,s){return this.db||await this.initialize(),new Promise((n,r)=>{const o=this.db.transaction(["messages"],"readwrite").objectStore("messages"),d=o.get(e);d.onerror=()=>r(d.error),d.onsuccess=()=>{const u=d.result;if(u){Object.assign(u,s);const b=o.put(u);b.onerror=()=>r(b.error),b.onsuccess=()=>n()}else r(new Error("Message not found"))}})}async saveSession(e){return this.db||await this.initialize(),new Promise((s,n)=>{const o=this.db.transaction(["sessions"],"readwrite").objectStore("sessions").put(e);o.onerror=()=>n(o.error),o.onsuccess=()=>s()})}async getSession(e){return this.db||await this.initialize(),new Promise((s,n)=>{const o=this.db.transaction(["sessions"],"readonly").objectStore("sessions").get(e);o.onerror=()=>n(o.error),o.onsuccess=()=>s(o.result||null)})}async getAllSessions(){return this.db||await this.initialize(),new Promise((e,s)=>{const o=this.db.transaction(["sessions"],"readonly").objectStore("sessions").index("createdAt").getAll();o.onerror=()=>s(o.error),o.onsuccess=()=>{const d=o.result.sort((u,b)=>b.createdAt-u.createdAt);e(d)}})}async deleteSession(e){return this.db||await this.initialize(),new Promise((s,n)=>{const r=this.db.transaction(["sessions","messages"],"readwrite"),a=r.objectStore("sessions"),o=r.objectStore("messages"),d=o.index("roomId");a.delete(e);const u=d.getAll(e);u.onsuccess=()=>{u.result.forEach(I=>{o.delete(I.id)})},r.onerror=()=>n(r.error),r.oncomplete=()=>s()})}async saveProfile(e){return this.db||await this.initialize(),new Promise((s,n)=>{const o=this.db.transaction(["profiles"],"readwrite").objectStore("profiles").put(e);o.onerror=()=>n(o.error),o.onsuccess=()=>s()})}async getProfile(e){return this.db||await this.initialize(),new Promise((s,n)=>{const o=this.db.transaction(["profiles"],"readonly").objectStore("profiles").get(e);o.onerror=()=>n(o.error),o.onsuccess=()=>s(o.result||null)})}async clearAllData(){return this.db||await this.initialize(),new Promise((e,s)=>{const n=this.db.transaction(["messages","sessions","profiles"],"readwrite"),r=n.objectStore("messages"),a=n.objectStore("sessions"),o=n.objectStore("profiles");r.clear(),a.clear(),o.clear(),n.onerror=()=>s(n.error),n.oncomplete=()=>e()})}close(){this.db&&(this.db.close(),this.db=null)}}class U{constructor(){m(this,"signalingClient",null);m(this,"storage");m(this,"currentRoomId",null);m(this,"popupPort",null);m(this,"isRoomInitiator",!1);m(this,"pendingSignals",[]);m(this,"hasPopupConnectedBefore",!1);this.storage=new B,this.initializeExtension()}async initializeExtension(){v.runtime.onMessage.addListener(this.handleMessage.bind(this)),v.runtime.onConnect.addListener(this.handleConnection.bind(this)),console.log("Crocro background service initialized")}handleConnection(e){console.log("Port connected:",e.name),e.name==="popup"&&(this.popupPort=e,e.onDisconnect.addListener(()=>{this.popupPort=null}),this.handlePopupConnection()),e.onMessage.addListener(async s=>{const n=await this.handleMessage(s,e.sender,()=>{});n&&e.postMessage(n)})}async handleMessage(e,s,n){console.log("Background received message:",e.type);try{switch(e.type){case"CREATE_ROOM":return await this.createRoom();case"JOIN_ROOM":return await this.joinRoom(e.payload.roomId);case"SEND_MESSAGE":return await this.sendMessage(e.payload.text);case"GET_MESSAGES":return await this.getMessages();case"LEAVE_ROOM":return await this.leaveRoom();case"SET_TYPING":return await this.setTyping(e.payload.isTyping);case"GET_CONNECTION_STATUS":return this.getConnectionStatus();case"RTC_SIGNAL":return await this.handleRTCSignal(e.payload);case"RTC_READY":return await this.notifyRTCReady();case"RTC_SEND_FAILED":return await this.handleRTCSendFailure(e.payload);case"SAVE_INCOMING_MESSAGE":return await this.saveIncomingMessage(e.payload);default:return console.warn("Unknown message type:",e.type),{error:"Unknown message type"}}}catch(r){return console.error("Error handling message:",r),{error:r instanceof Error?r.message:"Unknown error"}}}async createRoom(){try{const e="ws://localhost:8080";this.signalingClient=new F(e),await this.signalingClient.connect();const s=await this.signalingClient.createRoom();return this.currentRoomId=s,this.isRoomInitiator=!0,await this.initializeSignaling(),await this.storage.saveSession({roomId:s,createdAt:Date.now(),type:"creator"}),{roomId:s}}catch(e){return console.error("Failed to create room:",e),{error:e instanceof Error?e.message:"Failed to create room"}}}async joinRoom(e){try{const s="ws://localhost:8080";return this.signalingClient=new F(s),await this.signalingClient.connect(),await this.signalingClient.joinRoom(e),this.currentRoomId=e,this.isRoomInitiator=!1,await this.initializeSignaling(),await this.storage.saveSession({roomId:e,createdAt:Date.now(),type:"joiner"}),{success:!0}}catch(s){return console.error("Failed to join room:",s),{error:s instanceof Error?s.message:"Failed to join room"}}}async initializeSignaling(){!this.signalingClient||!this.currentRoomId||(this.signalingClient.onSignal=e=>{console.log("Background forwarding signal to popup:",e.type,"popupConnected:",!!this.popupPort),this.popupPort?(console.log("Sending signal to popup:",e),this.popupPort.postMessage({type:"SIGNALING_MESSAGE",payload:e})):(console.log("Popup not connected, queuing signal:",e.type),this.pendingSignals.push(e))},this.signalingClient.onMessage=async e=>{console.log("Background received relay message:",e),await this.handleIncomingMessage(e)},console.log("Signaling setup complete, waiting for peer connection..."))}handlePopupConnection(){if(this.pendingSignals.length>0){console.log("Sending",this.pendingSignals.length,"queued signals to popup");for(const e of this.pendingSignals)this.popupPort.postMessage({type:"SIGNALING_MESSAGE",payload:e});this.pendingSignals=[]}}async handleRTCSignal(e){return this.signalingClient?(this.signalingClient.sendSignal(e),{success:!0}):{success:!1}}async notifyRTCReady(){return console.log("Popup RTC manager is ready"),this.handlePopupConnection(),this.signalingClient&&this.currentRoomId&&this.hasPopupConnectedBefore&&(console.log(`Notifying signaling server of ${this.isRoomInitiator?"creator":"joiner"} reconnection`),this.signalingClient.sendSignal({type:"peer-reconnected",isInitiator:this.isRoomInitiator})),this.hasPopupConnectedBefore=!0,{success:!0}}async handleRTCSendFailure(e){return console.log("WebRTC send failed, falling back to signaling server relay"),this.signalingClient?(this.signalingClient.sendRelayMessage(e),{success:!0}):{success:!1}}async saveIncomingMessage(e){if(!this.currentRoomId)return{success:!1};try{const s={...e,from:"peer",roomId:this.currentRoomId};return await this.storage.saveMessage(s),this.notifyMessageReceived(s),{success:!0}}catch(s){return console.error("Error saving incoming message:",s),{success:!1}}}async sendMessage(e){if(!this.currentRoomId)return{error:"Not connected to a room"};try{const s={id:crypto.randomUUID(),roomId:this.currentRoomId,text:e,timestamp:Date.now(),from:"self"};return await this.storage.saveMessage(s),this.popupPort?this.popupPort.postMessage({type:"SEND_RTC_MESSAGE",payload:s}):this.signalingClient&&this.signalingClient.sendRelayMessage(s),this.notifyMessageSent(s),{success:!0}}catch(s){return console.error("Error sending message:",s),{error:s instanceof Error?s.message:"Failed to send message"}}}async handleIncomingMessage(e){if(!this.currentRoomId)return;const s={...e,from:"peer",roomId:this.currentRoomId};await this.storage.saveMessage(s),this.popupPort&&this.popupPort.postMessage({type:"RELAY_MESSAGE_RECEIVED",payload:s}),this.notifyMessageReceived(s)}async getMessages(){return this.currentRoomId?{messages:await this.storage.getMessages(this.currentRoomId)}:{messages:[]}}async leaveRoom(){return this.popupPort&&this.popupPort.postMessage({type:"CLOSE_RTC_CONNECTION"}),this.signalingClient&&(this.signalingClient.disconnect(),this.signalingClient=null),this.currentRoomId=null,this.isRoomInitiator=!1,this.pendingSignals=[],this.hasPopupConnectedBefore=!1,{success:!0}}async setTyping(e){return this.popupPort&&this.popupPort.postMessage({type:"SET_TYPING",payload:{isTyping:e}}),{success:!0}}getConnectionStatus(){var n;const e=((n=this.signalingClient)==null?void 0:n.getConnectionState())==="connected",s=e&&this.currentRoomId;return{connected:!1,roomId:this.currentRoomId,connectionState:s?"connecting":"disconnected",signaling:e,status:s?"connecting":"disconnected",isInitiator:this.isRoomInitiator}}notifyMessageSent(e){this.broadcastToUI("MESSAGE_SENT",e)}notifyMessageReceived(e){this.broadcastToUI("MESSAGE_RECEIVED",e)}async broadcastToUI(e,s){try{const n=await v.tabs.query({active:!0});for(const r of n)r.id&&v.tabs.sendMessage(r.id,{type:e,payload:s}).catch(()=>{})}catch(n){console.warn("Failed to broadcast to UI:",n)}}}new U})();
