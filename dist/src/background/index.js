var V=Object.defineProperty;var K=(x,b,M)=>b in x?V(x,b,{enumerable:!0,configurable:!0,writable:!0,value:M}):x[b]=M;var l=(x,b,M)=>K(x,typeof b!="symbol"?b+"":b,M);(function(){"use strict";var x=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function b(S){return S&&S.__esModule&&Object.prototype.hasOwnProperty.call(S,"default")?S.default:S}var M={exports:{}};(function(S,e){(function(n,s){s(S)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:x,function(n){var s,t;if(!((t=(s=globalThis.chrome)==null?void 0:s.runtime)!=null&&t.id))throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const a="The message port closed before a response was received.",r=m=>{const h={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(h).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class f extends WeakMap{constructor(i,g=void 0){super(g),this.createItem=i}get(i){return this.has(i)||this.set(i,this.createItem(i)),super.get(i)}}const I=o=>o&&typeof o=="object"&&typeof o.then=="function",v=(o,i)=>(...g)=>{m.runtime.lastError?o.reject(new Error(m.runtime.lastError.message)):i.singleCallbackArg||g.length<=1&&i.singleCallbackArg!==!1?o.resolve(g[0]):o.resolve(g)},k=o=>o==1?"argument":"arguments",U=(o,i)=>function(d,...A){if(A.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${k(i.minArgs)} for ${o}(), got ${A.length}`);if(A.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${k(i.maxArgs)} for ${o}(), got ${A.length}`);return new Promise((p,C)=>{if(i.fallbackToNoCallback)try{d[o](...A,v({resolve:p,reject:C},i))}catch(c){console.warn(`${o} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,c),d[o](...A),i.fallbackToNoCallback=!1,i.noCallback=!0,p()}else i.noCallback?(d[o](...A),p()):d[o](...A,v({resolve:p,reject:C},i))})},z=(o,i,g)=>new Proxy(i,{apply(d,A,p){return g.call(A,o,...p)}});let P=Function.call.bind(Object.prototype.hasOwnProperty);const N=(o,i={},g={})=>{let d=Object.create(null),A={has(C,c){return c in o||c in d},get(C,c,y){if(c in d)return d[c];if(!(c in o))return;let u=o[c];if(typeof u=="function")if(typeof i[c]=="function")u=z(o,o[c],i[c]);else if(P(g,c)){let R=U(c,g[c]);u=z(o,o[c],R)}else u=u.bind(o);else if(typeof u=="object"&&u!==null&&(P(i,c)||P(g,c)))u=N(u,i[c],g[c]);else if(P(g,"*"))u=N(u,i[c],g["*"]);else return Object.defineProperty(d,c,{configurable:!0,enumerable:!0,get(){return o[c]},set(R){o[c]=R}}),u;return d[c]=u,u},set(C,c,y,u){return c in d?d[c]=y:o[c]=y,!0},defineProperty(C,c,y){return Reflect.defineProperty(d,c,y)},deleteProperty(C,c){return Reflect.deleteProperty(d,c)}},p=Object.create(o);return new Proxy(p,A)},O=o=>({addListener(i,g,...d){i.addListener(o.get(g),...d)},hasListener(i,g){return i.hasListener(o.get(g))},removeListener(i,g){i.removeListener(o.get(g))}}),B=new f(o=>typeof o!="function"?o:function(g){const d=N(g,{},{getContent:{minArgs:0,maxArgs:0}});o(d)}),W=new f(o=>typeof o!="function"?o:function(g,d,A){let p=!1,C,c=new Promise(E=>{C=function(w){p=!0,E(w)}}),y;try{y=o(g,d,C)}catch(E){y=Promise.reject(E)}const u=y!==!0&&I(y);if(y!==!0&&!u&&!p)return!1;const R=E=>{E.then(w=>{A(w)},w=>{let D;w&&(w instanceof Error||typeof w.message=="string")?D=w.message:D="An unexpected error occurred",A({__mozWebExtensionPolyfillReject__:!0,message:D})}).catch(w=>{console.error("Failed to send onMessage rejected reply",w)})};return R(u?y:c),!0}),$=({reject:o,resolve:i},g)=>{m.runtime.lastError?m.runtime.lastError.message===a?i():o(new Error(m.runtime.lastError.message)):g&&g.__mozWebExtensionPolyfillReject__?o(new Error(g.message)):i(g)},F=(o,i,g,...d)=>{if(d.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${k(i.minArgs)} for ${o}(), got ${d.length}`);if(d.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${k(i.maxArgs)} for ${o}(), got ${d.length}`);return new Promise((A,p)=>{const C=$.bind(null,{resolve:A,reject:p});d.push(C),g.sendMessage(...d)})},J={devtools:{network:{onRequestFinished:O(B)}},runtime:{onMessage:O(W),onMessageExternal:O(W),sendMessage:F.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:F.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},j={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return h.privacy={network:{"*":j},services:{"*":j},websites:{"*":j}},N(m,J,h)};n.exports=r(chrome)}else n.exports=globalThis.browser})})(M);var H=M.exports;const T=b(H);class _{constructor(e){l(this,"ws",null);l(this,"url");l(this,"reconnectAttempts",0);l(this,"maxReconnectAttempts",5);l(this,"reconnectDelay",1e3);l(this,"isConnected",!1);l(this,"currentRoomId",null);l(this,"keepAliveInterval",null);l(this,"onSignal",null);l(this,"onMessage",null);l(this,"onConnected",null);l(this,"onDisconnected",null);l(this,"onError",null);l(this,"signalHandlers",new Set);this.url=e}async connect(){return new Promise((e,n)=>{try{this.ws=new WebSocket(this.url),this.ws.onopen=()=>{var s;console.log("Signaling client connected"),this.isConnected=!0,this.reconnectAttempts=0,this.startKeepAlive(),(s=this.onConnected)==null||s.call(this),e()},this.ws.onmessage=s=>{try{const t=JSON.parse(s.data);this.handleSignalMessage(t)}catch(t){console.error("Failed to parse signaling message:",t)}},this.ws.onclose=s=>{var t;console.log("Signaling connection closed:",s.code,s.reason),this.isConnected=!1,(t=this.onDisconnected)==null||t.call(this),!s.wasClean&&this.reconnectAttempts<this.maxReconnectAttempts?(console.log("Connection closed unexpectedly, scheduling reconnect..."),this.scheduleReconnect()):s.wasClean?console.log("Connection closed cleanly"):console.log("Max reconnect attempts reached")},this.ws.onerror=s=>{var a;console.error("Signaling connection error:",s);const t="WebSocket connection failed";(a=this.onError)==null||a.call(this,t),n(new Error(t))}}catch(s){n(s)}})}disconnect(){this.stopKeepAlive(),this.ws&&(this.ws.close(1e3,"Normal closure"),this.ws=null),this.isConnected=!1,this.currentRoomId=null}startKeepAlive(){this.stopKeepAlive(),this.keepAliveInterval=setInterval(()=>{var e;this.isConnected&&((e=this.ws)==null?void 0:e.readyState)===WebSocket.OPEN&&this.sendMessage({type:"ping"})},3e4)}stopKeepAlive(){this.keepAliveInterval&&(clearInterval(this.keepAliveInterval),this.keepAliveInterval=null)}async createRoom(e){return new Promise((n,s)=>{if(!this.isConnected){s(new Error("Not connected to signaling server"));return}const t=e||this.generateRoomId(),a=r=>{var m;r.type==="room-created"&&r.roomId===t?(this.currentRoomId=t,this.removeSignalHandler(a),n(t)):r.type==="error"&&r.roomId===t&&(this.removeSignalHandler(a),s(new Error(((m=r.data)==null?void 0:m.message)||"Failed to create room")))};this.addSignalHandler(a),this.sendMessage({type:"create-room",roomId:t})})}async joinRoom(e){return new Promise((n,s)=>{if(!this.isConnected){s(new Error("Not connected to signaling server"));return}const t=a=>{var r;a.type==="room-joined"&&a.roomId===e?(this.currentRoomId=e,this.removeSignalHandler(t),n()):a.type==="error"&&a.roomId===e&&(this.removeSignalHandler(t),s(new Error(((r=a.data)==null?void 0:r.message)||"Failed to join room")))};this.addSignalHandler(t),this.sendMessage({type:"join-room",roomId:e})})}sendSignal(e){if(!this.isConnected||!this.currentRoomId){console.warn("Cannot send signal: not connected or no active room");return}this.sendMessage({type:"signal",roomId:this.currentRoomId,data:e})}sendRelayMessage(e){if(!this.isConnected||!this.currentRoomId){console.warn("Cannot send relay message: not connected or no active room");return}this.sendMessage({type:"relay-message",roomId:this.currentRoomId,data:e})}handleSignalMessage(e){var n,s,t,a,r;switch(console.log("Received signaling message:",e.type,e),e.type){case"offer":case"answer":case"ice-candidate":(n=this.onSignal)==null||n.call(this,e);break;case"peer-joined":console.log("Peer joined room:",e.peerId),(s=this.onSignal)==null||s.call(this,{type:"peer-joined",peerId:e.peerId});break;case"peer-left":console.log("Peer left room:",e.peerId),(t=this.onSignal)==null||t.call(this,{type:"peer-left",peerId:e.peerId});break;case"peer-reconnected":console.log("Peer reconnected:",e.peerId),(a=this.onSignal)==null||a.call(this,e);break;case"relay-message":console.log("Received relay message from peer:",e.peerId),(r=this.onMessage)==null||r.call(this,e.data);break;default:this.signalHandlers.forEach(m=>m(e))}}addSignalHandler(e){this.signalHandlers.add(e)}removeSignalHandler(e){this.signalHandlers.delete(e)}sendMessage(e){this.ws&&this.ws.readyState===WebSocket.OPEN?this.ws.send(JSON.stringify(e)):console.warn("Cannot send message: WebSocket not open")}scheduleReconnect(){this.reconnectAttempts++;const e=this.reconnectDelay*Math.pow(2,this.reconnectAttempts-1);console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${e}ms`),setTimeout(()=>{this.isConnected||this.connect().catch(n=>{console.error("Reconnect failed:",n)})},e)}generateRoomId(){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";let n="";for(let s=0;s<6;s++)n+=e.charAt(Math.floor(Math.random()*e.length));return n}getConnectionState(){if(!this.ws)return"disconnected";switch(this.ws.readyState){case WebSocket.CONNECTING:return"connecting";case WebSocket.OPEN:return"connected";default:return"disconnected"}}}class G{constructor(){l(this,"db",null);l(this,"dbName","CrocroChat");l(this,"dbVersion",1)}async initialize(){return new Promise((e,n)=>{const s=indexedDB.open(this.dbName,this.dbVersion);s.onerror=()=>n(s.error),s.onsuccess=()=>{this.db=s.result,e()},s.onupgradeneeded=t=>{const a=t.target.result;if(!a.objectStoreNames.contains("messages")){const r=a.createObjectStore("messages",{keyPath:"id"});r.createIndex("roomId","roomId",{unique:!1}),r.createIndex("timestamp","timestamp",{unique:!1})}a.objectStoreNames.contains("sessions")||a.createObjectStore("sessions",{keyPath:"roomId"}).createIndex("createdAt","createdAt",{unique:!1}),a.objectStoreNames.contains("profiles")||a.createObjectStore("profiles",{keyPath:"id"})}})}async saveMessage(e){return this.db||await this.initialize(),new Promise((n,s)=>{const r=this.db.transaction(["messages"],"readwrite").objectStore("messages").put(e);r.onerror=()=>s(r.error),r.onsuccess=()=>n()})}async getMessages(e,n=100){return this.db||await this.initialize(),new Promise((s,t)=>{const h=this.db.transaction(["messages"],"readonly").objectStore("messages").index("roomId").getAll(e);h.onerror=()=>t(h.error),h.onsuccess=()=>{const f=h.result.sort((I,v)=>I.timestamp-v.timestamp).slice(-n);s(f)}})}async updateMessageStatus(e,n){return this.db||await this.initialize(),new Promise((s,t)=>{const r=this.db.transaction(["messages"],"readwrite").objectStore("messages"),m=r.get(e);m.onerror=()=>t(m.error),m.onsuccess=()=>{const h=m.result;if(h){Object.assign(h,n);const f=r.put(h);f.onerror=()=>t(f.error),f.onsuccess=()=>s()}else t(new Error("Message not found"))}})}async saveSession(e){return this.db||await this.initialize(),new Promise((n,s)=>{const r=this.db.transaction(["sessions"],"readwrite").objectStore("sessions").put(e);r.onerror=()=>s(r.error),r.onsuccess=()=>n()})}async getSession(e){return this.db||await this.initialize(),new Promise((n,s)=>{const r=this.db.transaction(["sessions"],"readonly").objectStore("sessions").get(e);r.onerror=()=>s(r.error),r.onsuccess=()=>n(r.result||null)})}async getAllSessions(){return this.db||await this.initialize(),new Promise((e,n)=>{const r=this.db.transaction(["sessions"],"readonly").objectStore("sessions").index("createdAt").getAll();r.onerror=()=>n(r.error),r.onsuccess=()=>{const m=r.result.sort((h,f)=>f.createdAt-h.createdAt);e(m)}})}async deleteSession(e){return this.db||await this.initialize(),new Promise((n,s)=>{const t=this.db.transaction(["sessions","messages"],"readwrite"),a=t.objectStore("sessions"),r=t.objectStore("messages"),m=r.index("roomId");a.delete(e);const h=m.getAll(e);h.onsuccess=()=>{h.result.forEach(I=>{r.delete(I.id)})},t.onerror=()=>s(t.error),t.oncomplete=()=>n()})}async saveProfile(e){return this.db||await this.initialize(),new Promise((n,s)=>{const r=this.db.transaction(["profiles"],"readwrite").objectStore("profiles").put(e);r.onerror=()=>s(r.error),r.onsuccess=()=>n()})}async getProfile(e){return this.db||await this.initialize(),new Promise((n,s)=>{const r=this.db.transaction(["profiles"],"readonly").objectStore("profiles").get(e);r.onerror=()=>s(r.error),r.onsuccess=()=>n(r.result||null)})}async clearAllData(){return this.db||await this.initialize(),new Promise((e,n)=>{const s=this.db.transaction(["messages","sessions","profiles"],"readwrite"),t=s.objectStore("messages"),a=s.objectStore("sessions"),r=s.objectStore("profiles");t.clear(),a.clear(),r.clear(),s.onerror=()=>n(s.error),s.oncomplete=()=>e()})}close(){this.db&&(this.db.close(),this.db=null)}}class q{constructor(e){l(this,"peerConnection",null);l(this,"dataChannel",null);l(this,"config");l(this,"isInitiator",!1);l(this,"connectionState","new");l(this,"onMessage",null);l(this,"onConnectionStateChange",null);l(this,"onSignal",null);this.config=e}async initialize(e=!1){console.log("RTCManager initializing, isInitiator:",e),this.isInitiator=e;const n=[...this.config.stunServers.map(s=>({urls:s})),...this.config.turnServers.map(s=>({urls:s,username:this.config.turnUsername,credential:this.config.turnPassword}))].filter(s=>s.urls);console.log("ICE servers configured:",n),this.peerConnection=new RTCPeerConnection({iceServers:n,iceCandidatePoolSize:10}),this.setupPeerConnectionEventHandlers(),this.isInitiator?(console.log("Creating data channel and offer as initiator"),this.createDataChannel(),await this.createOffer()):console.log("Waiting for incoming offer as joiner")}setupPeerConnectionEventHandlers(){this.peerConnection&&(this.peerConnection.onicecandidate=e=>{var n;e.candidate&&((n=this.onSignal)==null||n.call(this,{type:"ice-candidate",candidate:e.candidate}))},this.peerConnection.onconnectionstatechange=()=>{var e;this.peerConnection&&(this.connectionState=this.peerConnection.connectionState,console.log("RTC connection state changed:",this.connectionState),(e=this.onConnectionStateChange)==null||e.call(this,this.connectionState))},this.peerConnection.ondatachannel=e=>{this.isInitiator||(this.dataChannel=e.channel,this.setupDataChannelEventHandlers())},this.peerConnection.oniceconnectionstatechange=()=>{var e;console.log("ICE connection state:",(e=this.peerConnection)==null?void 0:e.iceConnectionState)},this.peerConnection.onicegatheringstatechange=()=>{var e;console.log("ICE gathering state:",(e=this.peerConnection)==null?void 0:e.iceGatheringState)})}createDataChannel(){this.peerConnection&&(this.dataChannel=this.peerConnection.createDataChannel("chat",{ordered:!0,maxRetransmits:3}),this.setupDataChannelEventHandlers())}setupDataChannelEventHandlers(){this.dataChannel&&(this.dataChannel.onopen=()=>{console.log("Data channel opened")},this.dataChannel.onclose=()=>{console.log("Data channel closed")},this.dataChannel.onerror=e=>{console.error("Data channel error:",e)},this.dataChannel.onmessage=e=>{try{const n=JSON.parse(e.data);this.handleDataChannelMessage(n)}catch(n){console.error("Failed to parse data channel message:",n)}})}handleDataChannelMessage(e){var n;switch(e.type){case"message":(n=this.onMessage)==null||n.call(this,e),this.sendAck(e.id);break;case"typing":console.log("Peer typing status:",e.isTyping);break;case"ack":console.log("Message delivered:",e.id);break;case"read-receipt":console.log("Message read:",e.id);break}}async createOffer(){var n;if(!this.peerConnection)return;const e=await this.peerConnection.createOffer();await this.peerConnection.setLocalDescription(e),(n=this.onSignal)==null||n.call(this,{type:"offer",sdp:e})}async handleSignal(e){if(console.log("RTCManager handling signal:",e.type,e),!this.peerConnection){console.error("No peer connection available for handling signal");return}try{switch(e.type){case"offer":console.log("Handling incoming offer"),await this.handleOffer(e.sdp||e);break;case"answer":console.log("Handling incoming answer"),await this.handleAnswer(e.sdp||e);break;case"ice-candidate":console.log("Handling ICE candidate"),await this.handleIceCandidate(e.candidate||e);break;default:console.warn("Unknown signal type:",e.type)}}catch(n){console.error("Error handling signal:",e.type,n)}}async handleOffer(e){var s;if(!this.peerConnection)return;console.log("Setting remote description with offer:",e),await this.peerConnection.setRemoteDescription(e);const n=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(n),console.log("Sending answer:",n),(s=this.onSignal)==null||s.call(this,{type:"answer",sdp:n})}async handleAnswer(e){this.peerConnection&&(console.log("Setting remote description with answer:",e),await this.peerConnection.setRemoteDescription(e))}async handleIceCandidate(e){this.peerConnection&&(console.log("Adding ICE candidate:",e),await this.peerConnection.addIceCandidate(e))}async sendMessage(e){if(!this.dataChannel||this.dataChannel.readyState!=="open")return console.warn("Data channel not ready for sending messages"),!1;try{const n={type:"message",id:e.id,text:e.text,timestamp:e.timestamp};return this.dataChannel.send(JSON.stringify(n)),!0}catch(n){return console.error("Failed to send message:",n),!1}}async sendTypingIndicator(e){if(!(!this.dataChannel||this.dataChannel.readyState!=="open"))try{const n={type:"typing",isTyping:e};this.dataChannel.send(JSON.stringify(n))}catch(n){console.error("Failed to send typing indicator:",n)}}sendAck(e){if(!(!this.dataChannel||this.dataChannel.readyState!=="open"))try{const n={type:"ack",id:e};this.dataChannel.send(JSON.stringify(n))}catch(n){console.error("Failed to send ack:",n)}}sendReadReceipt(e){if(!(!this.dataChannel||this.dataChannel.readyState!=="open"))try{const n={type:"read-receipt",id:e};this.dataChannel.send(JSON.stringify(n))}catch(n){console.error("Failed to send read receipt:",n)}}isConnected(){var e;return((e=this.dataChannel)==null?void 0:e.readyState)==="open"}getConnectionState(){return this.connectionState}getDataChannelState(){var e;return((e=this.dataChannel)==null?void 0:e.readyState)||null}close(){this.dataChannel&&(this.dataChannel.close(),this.dataChannel=null),this.peerConnection&&(this.peerConnection.close(),this.peerConnection=null),this.connectionState="closed"}}class L{constructor(){l(this,"signalingClient",null);l(this,"rtcManager",null);l(this,"storage");l(this,"currentRoomId",null);l(this,"popupPort",null);l(this,"isRoomInitiator",!1);l(this,"pendingMessages",[]);l(this,"isRelayConnected",!1);this.storage=new G,this.initializeExtension()}async initializeExtension(){T.runtime.onMessage.addListener(this.handleMessage.bind(this)),T.runtime.onConnect.addListener(this.handleConnection.bind(this)),console.log("Crocro background service initialized")}handleConnection(e){if(console.log("Port connected:",e.name),e.name==="popup"){this.popupPort=e,e.onDisconnect.addListener(()=>{this.popupPort=null});const n=this.getConnectionStatus();e.postMessage({type:"CONNECTION_STATE_CHANGED",payload:{state:n.status}}),this.handlePopupConnection()}e.onMessage.addListener(async n=>{const s=await this.handleMessage(n,e.sender,()=>{});s&&e.postMessage(s)})}async handleMessage(e,n,s){var t;console.log("Background received message:",e.type);try{switch(e.type){case"CREATE_ROOM":return await this.createRoom((t=e.payload)==null?void 0:t.roomId);case"JOIN_ROOM":return await this.joinRoom(e.payload.roomId);case"SEND_MESSAGE":return await this.sendMessage(e.payload.text);case"GET_MESSAGES":return await this.getMessages();case"GET_SESSIONS":return await this.getSessions();case"DELETE_SESSION":return await this.deleteSessionById(e.payload.roomId);case"LEAVE_ROOM":return await this.leaveRoom();case"SET_TYPING":return await this.setTyping(e.payload.isTyping);case"GET_CONNECTION_STATUS":return this.getConnectionStatus();case"GET_RTC_CONNECTION_STATE":return this.getRTCConnectionState();case"GET_PENDING_MESSAGES":return this.getPendingMessages();case"SAVE_INCOMING_MESSAGE":return await this.saveIncomingMessage(e.payload);default:return console.warn("Unknown message type:",e.type),{error:"Unknown message type"}}}catch(a){return console.error("Error handling message:",a),{error:a instanceof Error?a.message:"Unknown error"}}}async createRoom(e){try{const n="ws://localhost:8080";this.signalingClient=new _(n),await this.signalingClient.connect();const s=await this.signalingClient.createRoom(e);return this.currentRoomId=s,this.isRoomInitiator=!0,await this.initializeSignaling(),await this.initializeRTC(),await this.storage.saveSession({roomId:s,createdAt:Date.now(),type:"creator"}),{roomId:s}}catch(n){return console.error("Failed to create room:",n),{error:n instanceof Error?n.message:"Failed to create room"}}}async joinRoom(e){try{const n="ws://localhost:8080";return this.signalingClient=new _(n),await this.signalingClient.connect(),await this.signalingClient.joinRoom(e),this.currentRoomId=e,this.isRoomInitiator=!1,await this.initializeSignaling(),await this.initializeRTC(),await this.storage.saveSession({roomId:e,createdAt:Date.now(),type:"joiner"}),{success:!0}}catch(n){return console.error("Failed to join room:",n),{error:n instanceof Error?n.message:"Failed to join room"}}}async initializeSignaling(){!this.signalingClient||!this.currentRoomId||(this.signalingClient.onSignal=e=>{var n;console.log("Background received signaling message:",e.type),e.type==="peer-joined"&&typeof RTCPeerConnection>"u"&&(console.log("Peer joined, WebRTC not available, using relay-only mode"),this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")),e.type==="room-joined"&&!this.isRoomInitiator&&typeof RTCPeerConnection>"u"&&(console.log("Joined room successfully, WebRTC not available, using relay-only mode"),e.hasPeer||((n=e.peers)==null?void 0:n.length)>1?(console.log("Room already has peer, marking as connected via relay"),this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")):(console.log("Room empty, waiting for peer to join"),this.notifyConnectionStateChange("connecting"))),e.type==="room-created"&&this.isRoomInitiator&&typeof RTCPeerConnection>"u"&&(console.log("Room created successfully, WebRTC not available, using relay-only mode (waiting for peer)"),this.notifyConnectionStateChange("connecting")),this.handleRTCSignal(e)},this.signalingClient.onMessage=async e=>{console.log("Background received relay message:",e),await this.handleIncomingMessage(e)},console.log("Signaling setup complete, waiting for peer connection..."))}async initializeRTC(){if(typeof RTCPeerConnection>"u"){console.log("WebRTC APIs not available in background service worker, using relay-only mode"),this.rtcManager=null;return}this.rtcManager&&(console.log("Cleaning up existing RTC manager"),this.rtcManager.close(),this.rtcManager=null);try{const e=this.getRTCConfig();this.rtcManager=new q(e),this.rtcManager.onMessage=n=>{this.handleIncomingRTCMessage(n)},this.rtcManager.onConnectionStateChange=n=>{console.log("Background RTC connection state changed:",n),this.notifyConnectionStateChange(n),n==="connected"&&this.pendingMessages.length>0&&this.sendQueuedMessages()},this.rtcManager.onSignal=n=>{this.signalingClient&&this.signalingClient.sendSignal(n)},this.isRoomInitiator&&(console.log("Initializing WebRTC as initiator (creator)"),await this.rtcManager.initialize(!0)),console.log("Background RTC manager initialized")}catch(e){console.error("Failed to initialize WebRTC in background, falling back to relay-only:",e),this.rtcManager=null}}handlePopupConnection(){if(this.pendingMessages.length>0&&this.popupPort){console.log("Sending",this.pendingMessages.length,"pending messages to popup");for(const e of this.pendingMessages)this.popupPort.postMessage({type:"PENDING_MESSAGE",payload:e});this.pendingMessages=[]}}async handleRTCSignal(e){var n;if(console.log("Background handling RTC signal:",e.type),typeof RTCPeerConnection>"u"||!this.rtcManager){console.log("WebRTC not available, skipping signal handling:",e.type),e.type==="peer-joined"?(this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")):e.type==="peer-left"&&(this.isRelayConnected=!1,this.notifyConnectionStateChange("connecting"));return}if(e.type==="peer-joined")console.log("Peer joined, starting WebRTC as initiator:",this.isRoomInitiator),this.isRoomInitiator&&this.rtcManager&&setTimeout(()=>{this.rtcManager&&(console.log("Initializing WebRTC as initiator:",this.isRoomInitiator),this.rtcManager.initialize(this.isRoomInitiator))},100);else if(e.type==="peer-reconnected")console.log("Peer reconnected, signal data:",e),(e.isInitiator||((n=e.data)==null?void 0:n.isInitiator))===!1&&this.isRoomInitiator&&this.rtcManager&&(console.log("Joiner reconnected, re-initializing WebRTC as initiator"),setTimeout(()=>{this.rtcManager&&this.rtcManager.initialize(this.isRoomInitiator)},100));else if(e.type==="offer"){if(console.log("Received offer signal, rtcManager exists:",!!this.rtcManager),this.rtcManager||(console.log("Creating new RTCManager for joiner"),await this.initializeRTC()),this.rtcManager){const s=this.rtcManager.getConnectionState();console.log("RTCManager state:",s),(s==="new"||s==="closed"||s==="disconnected")&&(console.log("Re-initializing RTCManager as joiner"),await this.rtcManager.initialize(!1)),await this.rtcManager.handleSignal(e)}}else this.rtcManager&&(console.log("Forwarding signal to RTC manager:",e.type),this.rtcManager.handleSignal(e))}getRTCConfig(){const e=JSON.parse('["stun:stun.l.google.com:19302"]'),n=JSON.parse("[]");return{stunServers:e,turnServers:n,turnUsername:"",turnPassword:""}}async handleIncomingRTCMessage(e){if(!this.currentRoomId)return;const n={...e,from:"peer",roomId:this.currentRoomId};await this.storage.saveMessage(n),this.popupPort?this.popupPort.postMessage({type:"RTC_MESSAGE_RECEIVED",payload:n}):this.pendingMessages.push(n),this.notifyMessageReceived(n)}async sendQueuedMessages(){!this.rtcManager||!this.rtcManager.isConnected()||console.log("Sending queued messages via WebRTC")}getRTCConnectionState(){var e,n,s;return{connected:((e=this.rtcManager)==null?void 0:e.isConnected())||!1,connectionState:((n=this.rtcManager)==null?void 0:n.getConnectionState())||"disconnected",dataChannelState:((s=this.rtcManager)==null?void 0:s.getDataChannelState())||null}}getPendingMessages(){return{messages:this.pendingMessages}}async getSessions(){try{return{sessions:await this.storage.getAllSessions()}}catch(e){return console.error("Error getting sessions:",e),{sessions:[]}}}async deleteSessionById(e){try{return await this.storage.deleteSession(e),{success:!0}}catch(n){return console.error("Error deleting session:",n),{success:!1}}}async saveIncomingMessage(e){if(!this.currentRoomId)return{success:!1};try{const n={...e,from:"peer",roomId:this.currentRoomId};return await this.storage.saveMessage(n),this.notifyMessageReceived(n),{success:!0}}catch(n){return console.error("Error saving incoming message:",n),{success:!1}}}async sendMessage(e){if(!this.currentRoomId)return{error:"Not connected to a room"};try{const n={id:crypto.randomUUID(),roomId:this.currentRoomId,text:e,timestamp:Date.now(),from:"self"};await this.storage.saveMessage(n);let s=!1;return this.rtcManager&&this.rtcManager.isConnected()&&(await this.rtcManager.sendMessage(n)?(s=!0,console.log("Message sent via WebRTC")):console.log("WebRTC send failed, falling back to relay")),s||(console.log("Sending message via relay (WebRTC not available or failed)"),this.signalingClient&&(this.signalingClient.sendRelayMessage(n),s=!0)),this.notifyMessageSent(n),{success:!0}}catch(n){return console.error("Error sending message:",n),{error:n instanceof Error?n.message:"Failed to send message"}}}async handleIncomingMessage(e){if(!this.currentRoomId)return;const n={...e,from:"peer",roomId:this.currentRoomId};await this.storage.saveMessage(n),this.popupPort&&this.popupPort.postMessage({type:"RELAY_MESSAGE_RECEIVED",payload:n}),this.notifyMessageReceived(n)}async getMessages(){return this.currentRoomId?{messages:await this.storage.getMessages(this.currentRoomId)}:{messages:[]}}async leaveRoom(){return this.rtcManager&&(this.rtcManager.close(),this.rtcManager=null),this.signalingClient&&(this.signalingClient.disconnect(),this.signalingClient=null),this.currentRoomId=null,this.isRoomInitiator=!1,this.isRelayConnected=!1,this.pendingMessages=[],{success:!0}}async setTyping(e){return this.rtcManager&&this.rtcManager.isConnected()&&await this.rtcManager.sendTypingIndicator(e),{success:!0}}getConnectionStatus(){var m,h,f;const e=((m=this.signalingClient)==null?void 0:m.getConnectionState())==="connected",n=((h=this.rtcManager)==null?void 0:h.isConnected())||!1,s=((f=this.rtcManager)==null?void 0:f.getConnectionState())||"disconnected",t=n||typeof RTCPeerConnection>"u"&&this.isRelayConnected,a=n?s:this.isRelayConnected?"connected":"connecting";let r="disconnected";return t?r="connected":e&&this.currentRoomId&&(r="connecting"),{connected:t,roomId:this.currentRoomId,connectionState:a,signaling:e,status:r,isInitiator:this.isRoomInitiator}}notifyMessageSent(e){this.broadcastToUI("MESSAGE_SENT",e)}notifyMessageReceived(e){this.broadcastToUI("MESSAGE_RECEIVED",e)}notifyConnectionStateChange(e){this.broadcastToUI("CONNECTION_STATE_CHANGED",{state:e}),this.popupPort&&this.popupPort.postMessage({type:"CONNECTION_STATE_CHANGED",payload:{state:e}})}async broadcastToUI(e,n){try{const s=await T.tabs.query({active:!0});for(const t of s)t.id&&T.tabs.sendMessage(t.id,{type:e,payload:n}).catch(()=>{})}catch(s){console.warn("Failed to broadcast to UI:",s)}}}new L})();
