var V=Object.defineProperty;var K=(x,b,M)=>b in x?V(x,b,{enumerable:!0,configurable:!0,writable:!0,value:M}):x[b]=M;var g=(x,b,M)=>K(x,typeof b!="symbol"?b+"":b,M);(function(){"use strict";var x=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function b(S){return S&&S.__esModule&&Object.prototype.hasOwnProperty.call(S,"default")?S.default:S}var M={exports:{}};(function(S,e){(function(n,t){t(S)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:x,function(n){var t,r;if(!((r=(t=globalThis.chrome)==null?void 0:t.runtime)!=null&&r.id))throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const a="The message port closed before a response was received.",s=l=>{const m={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(m).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class f extends WeakMap{constructor(i,d=void 0){super(d),this.createItem=i}get(i){return this.has(i)||this.set(i,this.createItem(i)),super.get(i)}}const E=o=>o&&typeof o=="object"&&typeof o.then=="function",v=(o,i)=>(...d)=>{l.runtime.lastError?o.reject(new Error(l.runtime.lastError.message)):i.singleCallbackArg||d.length<=1&&i.singleCallbackArg!==!1?o.resolve(d[0]):o.resolve(d)},k=o=>o==1?"argument":"arguments",G=(o,i)=>function(h,...A){if(A.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${k(i.minArgs)} for ${o}(), got ${A.length}`);if(A.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${k(i.maxArgs)} for ${o}(), got ${A.length}`);return new Promise((p,C)=>{if(i.fallbackToNoCallback)try{h[o](...A,v({resolve:p,reject:C},i))}catch(c){console.warn(`${o} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,c),h[o](...A),i.fallbackToNoCallback=!1,i.noCallback=!0,p()}else i.noCallback?(h[o](...A),p()):h[o](...A,v({resolve:p,reject:C},i))})},W=(o,i,d)=>new Proxy(i,{apply(h,A,p){return d.call(A,o,...p)}});let P=Function.call.bind(Object.prototype.hasOwnProperty);const N=(o,i={},d={})=>{let h=Object.create(null),A={has(C,c){return c in o||c in h},get(C,c,y){if(c in h)return h[c];if(!(c in o))return;let u=o[c];if(typeof u=="function")if(typeof i[c]=="function")u=W(o,o[c],i[c]);else if(P(d,c)){let R=G(c,d[c]);u=W(o,o[c],R)}else u=u.bind(o);else if(typeof u=="object"&&u!==null&&(P(i,c)||P(d,c)))u=N(u,i[c],d[c]);else if(P(d,"*"))u=N(u,i[c],d["*"]);else return Object.defineProperty(h,c,{configurable:!0,enumerable:!0,get(){return o[c]},set(R){o[c]=R}}),u;return h[c]=u,u},set(C,c,y,u){return c in h?h[c]=y:o[c]=y,!0},defineProperty(C,c,y){return Reflect.defineProperty(h,c,y)},deleteProperty(C,c){return Reflect.deleteProperty(h,c)}},p=Object.create(o);return new Proxy(p,A)},O=o=>({addListener(i,d,...h){i.addListener(o.get(d),...h)},hasListener(i,d){return i.hasListener(o.get(d))},removeListener(i,d){i.removeListener(o.get(d))}}),q=new f(o=>typeof o!="function"?o:function(d){const h=N(d,{},{getContent:{minArgs:0,maxArgs:0}});o(h)}),z=new f(o=>typeof o!="function"?o:function(d,h,A){let p=!1,C,c=new Promise(I=>{C=function(w){p=!0,I(w)}}),y;try{y=o(d,h,C)}catch(I){y=Promise.reject(I)}const u=y!==!0&&E(y);if(y!==!0&&!u&&!p)return!1;const R=I=>{I.then(w=>{A(w)},w=>{let D;w&&(w instanceof Error||typeof w.message=="string")?D=w.message:D="An unexpected error occurred",A({__mozWebExtensionPolyfillReject__:!0,message:D})}).catch(w=>{console.error("Failed to send onMessage rejected reply",w)})};return R(u?y:c),!0}),B=({reject:o,resolve:i},d)=>{l.runtime.lastError?l.runtime.lastError.message===a?i():o(new Error(l.runtime.lastError.message)):d&&d.__mozWebExtensionPolyfillReject__?o(new Error(d.message)):i(d)},F=(o,i,d,...h)=>{if(h.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${k(i.minArgs)} for ${o}(), got ${h.length}`);if(h.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${k(i.maxArgs)} for ${o}(), got ${h.length}`);return new Promise((A,p)=>{const C=B.bind(null,{resolve:A,reject:p});h.push(C),d.sendMessage(...h)})},J={devtools:{network:{onRequestFinished:O(q)}},runtime:{onMessage:O(z),onMessageExternal:O(z),sendMessage:F.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:F.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},j={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return m.privacy={network:{"*":j},services:{"*":j},websites:{"*":j}},N(l,J,m)};n.exports=s(chrome)}else n.exports=globalThis.browser})})(M);var U=M.exports;const T=b(U);class _{constructor(e){g(this,"ws",null);g(this,"urls");g(this,"reconnectAttempts",0);g(this,"maxReconnectAttempts",5);g(this,"reconnectDelay",1e3);g(this,"isConnected",!1);g(this,"currentRoomId",null);g(this,"keepAliveInterval",null);g(this,"onSignal",null);g(this,"onMessage",null);g(this,"onConnected",null);g(this,"onDisconnected",null);g(this,"onError",null);g(this,"signalHandlers",new Set);if(e.includes("localhost"))if(e.startsWith("ws://")){const n=e.replace("ws://","").replace(":8080","");this.urls=[`wss://${n}:8443`,`ws://${n}:8080`]}else if(e.startsWith("wss://")){const n=e.replace("wss://","").replace(":8443","");this.urls=[`wss://${n}:8443`,`ws://${n}:8080`]}else this.urls=[e];else this.urls=[e]}async connect(){return new Promise((e,n)=>{this.tryConnect(0,e,n)})}tryConnect(e,n,t){var a;if(e>=this.urls.length){const s=`Failed to connect to any WebSocket URL: ${this.urls.join(", ")}`;(a=this.onError)==null||a.call(this,s),t(new Error(s));return}const r=this.urls[e];console.log(`Trying to connect to: ${r}`);try{this.ws=new WebSocket(r),this.ws.onopen=()=>{var s;console.log(`Signaling client connected to: ${r}`),this.isConnected=!0,this.reconnectAttempts=0,this.startKeepAlive(),(s=this.onConnected)==null||s.call(this),n()},this.ws.onmessage=s=>{try{const l=JSON.parse(s.data);this.handleSignalMessage(l)}catch(l){console.error("Failed to parse signaling message:",l)}},this.ws.onclose=s=>{var l;console.log("Signaling connection closed:",s.code,s.reason),this.isConnected=!1,(l=this.onDisconnected)==null||l.call(this),!s.wasClean&&this.reconnectAttempts<this.maxReconnectAttempts?(console.log("Connection closed unexpectedly, scheduling reconnect..."),this.scheduleReconnect()):s.wasClean?console.log("Connection closed cleanly"):console.log("Max reconnect attempts reached")},this.ws.onerror=s=>{var l;if(console.error(`WebSocket connection error for ${r}:`,s),e+1<this.urls.length)console.log("Trying next URL fallback..."),this.tryConnect(e+1,n,t);else{const m=`WebSocket connection failed to all URLs: ${this.urls.join(", ")}`;(l=this.onError)==null||l.call(this,m),t(new Error(m))}}}catch(s){e+1<this.urls.length?this.tryConnect(e+1,n,t):t(s instanceof Error?s:new Error("Unknown error"))}}disconnect(){this.stopKeepAlive(),this.ws&&(this.ws.close(1e3,"Normal closure"),this.ws=null),this.isConnected=!1,this.currentRoomId=null}startKeepAlive(){this.stopKeepAlive(),this.keepAliveInterval=setInterval(()=>{var e;this.isConnected&&((e=this.ws)==null?void 0:e.readyState)===WebSocket.OPEN&&this.sendMessage({type:"ping"})},3e4)}stopKeepAlive(){this.keepAliveInterval&&(clearInterval(this.keepAliveInterval),this.keepAliveInterval=null)}async createRoom(e){return new Promise((n,t)=>{if(!this.isConnected){t(new Error("Not connected to signaling server"));return}const r=e||this.generateRoomId(),a=s=>{var l;s.type==="room-created"&&s.roomId===r?(this.currentRoomId=r,this.removeSignalHandler(a),n(r)):s.type==="error"&&s.roomId===r&&(this.removeSignalHandler(a),t(new Error(((l=s.data)==null?void 0:l.message)||"Failed to create room")))};this.addSignalHandler(a),this.sendMessage({type:"create-room",roomId:r})})}async joinRoom(e){return new Promise((n,t)=>{if(!this.isConnected){t(new Error("Not connected to signaling server"));return}const r=a=>{var s;a.type==="room-joined"&&a.roomId===e?(this.currentRoomId=e,this.removeSignalHandler(r),n()):a.type==="error"&&a.roomId===e&&(this.removeSignalHandler(r),t(new Error(((s=a.data)==null?void 0:s.message)||"Failed to join room")))};this.addSignalHandler(r),this.sendMessage({type:"join-room",roomId:e})})}sendSignal(e){if(!this.isConnected||!this.currentRoomId){console.warn("Cannot send signal: not connected or no active room");return}this.sendMessage({type:"signal",roomId:this.currentRoomId,data:e})}sendRelayMessage(e){if(!this.isConnected||!this.currentRoomId){console.warn("Cannot send relay message: not connected or no active room");return}this.sendMessage({type:"relay-message",roomId:this.currentRoomId,data:e})}handleSignalMessage(e){var n,t,r,a,s;switch(console.log("Received signaling message:",e.type,e),e.type){case"offer":case"answer":case"ice-candidate":(n=this.onSignal)==null||n.call(this,e);break;case"peer-joined":console.log("Peer joined room:",e.peerId),(t=this.onSignal)==null||t.call(this,{type:"peer-joined",peerId:e.peerId});break;case"peer-left":console.log("Peer left room:",e.peerId),(r=this.onSignal)==null||r.call(this,{type:"peer-left",peerId:e.peerId});break;case"peer-reconnected":console.log("Peer reconnected:",e.peerId),(a=this.onSignal)==null||a.call(this,e);break;case"relay-message":console.log("Received relay message from peer:",e.peerId),(s=this.onMessage)==null||s.call(this,e.data);break;default:this.signalHandlers.forEach(l=>l(e))}}addSignalHandler(e){this.signalHandlers.add(e)}removeSignalHandler(e){this.signalHandlers.delete(e)}sendMessage(e){this.ws&&this.ws.readyState===WebSocket.OPEN?this.ws.send(JSON.stringify(e)):console.warn("Cannot send message: WebSocket not open")}scheduleReconnect(){this.reconnectAttempts++;const e=this.reconnectDelay*Math.pow(2,this.reconnectAttempts-1);console.log(`Scheduling reconnect attempt ${this.reconnectAttempts} in ${e}ms`),setTimeout(()=>{this.isConnected||this.connect().catch(n=>{console.error("Reconnect failed:",n)})},e)}generateRoomId(){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";let n="";for(let t=0;t<6;t++)n+=e.charAt(Math.floor(Math.random()*e.length));return n}getConnectionState(){if(!this.ws)return"disconnected";switch(this.ws.readyState){case WebSocket.CONNECTING:return"connecting";case WebSocket.OPEN:return"connected";default:return"disconnected"}}}class H{constructor(){g(this,"db",null);g(this,"dbName","CrocroChat");g(this,"dbVersion",1)}async initialize(){return new Promise((e,n)=>{const t=indexedDB.open(this.dbName,this.dbVersion);t.onerror=()=>n(t.error),t.onsuccess=()=>{this.db=t.result,e()},t.onupgradeneeded=r=>{const a=r.target.result;if(!a.objectStoreNames.contains("messages")){const s=a.createObjectStore("messages",{keyPath:"id"});s.createIndex("roomId","roomId",{unique:!1}),s.createIndex("timestamp","timestamp",{unique:!1})}a.objectStoreNames.contains("sessions")||a.createObjectStore("sessions",{keyPath:"roomId"}).createIndex("createdAt","createdAt",{unique:!1}),a.objectStoreNames.contains("profiles")||a.createObjectStore("profiles",{keyPath:"id"})}})}async saveMessage(e){return this.db||await this.initialize(),new Promise((n,t)=>{const s=this.db.transaction(["messages"],"readwrite").objectStore("messages").put(e);s.onerror=()=>t(s.error),s.onsuccess=()=>n()})}async getMessages(e,n=100){return this.db||await this.initialize(),new Promise((t,r)=>{const m=this.db.transaction(["messages"],"readonly").objectStore("messages").index("roomId").getAll(e);m.onerror=()=>r(m.error),m.onsuccess=()=>{const f=m.result.sort((E,v)=>E.timestamp-v.timestamp).slice(-n);t(f)}})}async updateMessageStatus(e,n){return this.db||await this.initialize(),new Promise((t,r)=>{const s=this.db.transaction(["messages"],"readwrite").objectStore("messages"),l=s.get(e);l.onerror=()=>r(l.error),l.onsuccess=()=>{const m=l.result;if(m){Object.assign(m,n);const f=s.put(m);f.onerror=()=>r(f.error),f.onsuccess=()=>t()}else r(new Error("Message not found"))}})}async saveSession(e){return this.db||await this.initialize(),new Promise((n,t)=>{const s=this.db.transaction(["sessions"],"readwrite").objectStore("sessions").put(e);s.onerror=()=>t(s.error),s.onsuccess=()=>n()})}async getSession(e){return this.db||await this.initialize(),new Promise((n,t)=>{const s=this.db.transaction(["sessions"],"readonly").objectStore("sessions").get(e);s.onerror=()=>t(s.error),s.onsuccess=()=>n(s.result||null)})}async getAllSessions(){return this.db||await this.initialize(),new Promise((e,n)=>{const s=this.db.transaction(["sessions"],"readonly").objectStore("sessions").index("createdAt").getAll();s.onerror=()=>n(s.error),s.onsuccess=()=>{const l=s.result.sort((m,f)=>f.createdAt-m.createdAt);e(l)}})}async deleteSession(e){return this.db||await this.initialize(),new Promise((n,t)=>{const r=this.db.transaction(["sessions","messages"],"readwrite"),a=r.objectStore("sessions"),s=r.objectStore("messages"),l=s.index("roomId");a.delete(e);const m=l.getAll(e);m.onsuccess=()=>{m.result.forEach(E=>{s.delete(E.id)})},r.onerror=()=>t(r.error),r.oncomplete=()=>n()})}async saveProfile(e){return this.db||await this.initialize(),new Promise((n,t)=>{const s=this.db.transaction(["profiles"],"readwrite").objectStore("profiles").put(e);s.onerror=()=>t(s.error),s.onsuccess=()=>n()})}async getProfile(e){return this.db||await this.initialize(),new Promise((n,t)=>{const s=this.db.transaction(["profiles"],"readonly").objectStore("profiles").get(e);s.onerror=()=>t(s.error),s.onsuccess=()=>n(s.result||null)})}async clearAllData(){return this.db||await this.initialize(),new Promise((e,n)=>{const t=this.db.transaction(["messages","sessions","profiles"],"readwrite"),r=t.objectStore("messages"),a=t.objectStore("sessions"),s=t.objectStore("profiles");r.clear(),a.clear(),s.clear(),t.onerror=()=>n(t.error),t.oncomplete=()=>e()})}close(){this.db&&(this.db.close(),this.db=null)}}class L{constructor(e){g(this,"peerConnection",null);g(this,"dataChannel",null);g(this,"config");g(this,"isInitiator",!1);g(this,"connectionState","new");g(this,"onMessage",null);g(this,"onConnectionStateChange",null);g(this,"onSignal",null);this.config=e}async initialize(e=!1){console.log("RTCManager initializing, isInitiator:",e),this.isInitiator=e;const n=[...this.config.stunServers.map(t=>({urls:t})),...this.config.turnServers.map(t=>({urls:t,username:this.config.turnUsername,credential:this.config.turnPassword}))].filter(t=>t.urls);console.log("ICE servers configured:",n),this.peerConnection=new RTCPeerConnection({iceServers:n,iceCandidatePoolSize:10}),this.setupPeerConnectionEventHandlers(),this.isInitiator?(console.log("Creating data channel and offer as initiator"),this.createDataChannel(),await this.createOffer()):console.log("Waiting for incoming offer as joiner")}setupPeerConnectionEventHandlers(){this.peerConnection&&(this.peerConnection.onicecandidate=e=>{var n;e.candidate&&((n=this.onSignal)==null||n.call(this,{type:"ice-candidate",candidate:e.candidate}))},this.peerConnection.onconnectionstatechange=()=>{var e;this.peerConnection&&(this.connectionState=this.peerConnection.connectionState,console.log("RTC connection state changed:",this.connectionState),(e=this.onConnectionStateChange)==null||e.call(this,this.connectionState))},this.peerConnection.ondatachannel=e=>{this.isInitiator||(this.dataChannel=e.channel,this.setupDataChannelEventHandlers())},this.peerConnection.oniceconnectionstatechange=()=>{var e;console.log("ICE connection state:",(e=this.peerConnection)==null?void 0:e.iceConnectionState)},this.peerConnection.onicegatheringstatechange=()=>{var e;console.log("ICE gathering state:",(e=this.peerConnection)==null?void 0:e.iceGatheringState)})}createDataChannel(){this.peerConnection&&(this.dataChannel=this.peerConnection.createDataChannel("chat",{ordered:!0,maxRetransmits:3}),this.setupDataChannelEventHandlers())}setupDataChannelEventHandlers(){this.dataChannel&&(this.dataChannel.onopen=()=>{console.log("Data channel opened")},this.dataChannel.onclose=()=>{console.log("Data channel closed")},this.dataChannel.onerror=e=>{console.error("Data channel error:",e)},this.dataChannel.onmessage=e=>{try{const n=JSON.parse(e.data);this.handleDataChannelMessage(n)}catch(n){console.error("Failed to parse data channel message:",n)}})}handleDataChannelMessage(e){var n;switch(e.type){case"message":(n=this.onMessage)==null||n.call(this,e),this.sendAck(e.id);break;case"typing":console.log("Peer typing status:",e.isTyping);break;case"ack":console.log("Message delivered:",e.id);break;case"read-receipt":console.log("Message read:",e.id);break}}async createOffer(){var n;if(!this.peerConnection)return;const e=await this.peerConnection.createOffer();await this.peerConnection.setLocalDescription(e),(n=this.onSignal)==null||n.call(this,{type:"offer",sdp:e})}async handleSignal(e){if(console.log("RTCManager handling signal:",e.type,e),!this.peerConnection){console.error("No peer connection available for handling signal");return}try{switch(e.type){case"offer":console.log("Handling incoming offer"),await this.handleOffer(e.sdp||e);break;case"answer":console.log("Handling incoming answer"),await this.handleAnswer(e.sdp||e);break;case"ice-candidate":console.log("Handling ICE candidate"),await this.handleIceCandidate(e.candidate||e);break;default:console.warn("Unknown signal type:",e.type)}}catch(n){console.error("Error handling signal:",e.type,n)}}async handleOffer(e){var t;if(!this.peerConnection)return;console.log("Setting remote description with offer:",e),await this.peerConnection.setRemoteDescription(e);const n=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(n),console.log("Sending answer:",n),(t=this.onSignal)==null||t.call(this,{type:"answer",sdp:n})}async handleAnswer(e){this.peerConnection&&(console.log("Setting remote description with answer:",e),await this.peerConnection.setRemoteDescription(e))}async handleIceCandidate(e){this.peerConnection&&(console.log("Adding ICE candidate:",e),await this.peerConnection.addIceCandidate(e))}async sendMessage(e){if(!this.dataChannel||this.dataChannel.readyState!=="open")return console.warn("Data channel not ready for sending messages"),!1;try{const n={type:"message",id:e.id,text:e.text,timestamp:e.timestamp};return this.dataChannel.send(JSON.stringify(n)),!0}catch(n){return console.error("Failed to send message:",n),!1}}async sendTypingIndicator(e){if(!(!this.dataChannel||this.dataChannel.readyState!=="open"))try{const n={type:"typing",isTyping:e};this.dataChannel.send(JSON.stringify(n))}catch(n){console.error("Failed to send typing indicator:",n)}}sendAck(e){if(!(!this.dataChannel||this.dataChannel.readyState!=="open"))try{const n={type:"ack",id:e};this.dataChannel.send(JSON.stringify(n))}catch(n){console.error("Failed to send ack:",n)}}sendReadReceipt(e){if(!(!this.dataChannel||this.dataChannel.readyState!=="open"))try{const n={type:"read-receipt",id:e};this.dataChannel.send(JSON.stringify(n))}catch(n){console.error("Failed to send read receipt:",n)}}isConnected(){var e;return((e=this.dataChannel)==null?void 0:e.readyState)==="open"}getConnectionState(){return this.connectionState}getDataChannelState(){var e;return((e=this.dataChannel)==null?void 0:e.readyState)||null}close(){this.dataChannel&&(this.dataChannel.close(),this.dataChannel=null),this.peerConnection&&(this.peerConnection.close(),this.peerConnection=null),this.connectionState="closed"}}class ${constructor(){g(this,"signalingClient",null);g(this,"rtcManager",null);g(this,"storage");g(this,"currentRoomId",null);g(this,"popupPort",null);g(this,"isRoomInitiator",!1);g(this,"pendingMessages",[]);g(this,"isRelayConnected",!1);this.storage=new H,this.initializeExtension()}async initializeExtension(){T.runtime.onMessage.addListener(this.handleMessage.bind(this)),T.runtime.onConnect.addListener(this.handleConnection.bind(this)),console.log("Crocro background service initialized")}handleConnection(e){if(console.log("Port connected:",e.name),e.name==="popup"){this.popupPort=e,e.onDisconnect.addListener(()=>{this.popupPort=null});const n=this.getConnectionStatus();e.postMessage({type:"CONNECTION_STATE_CHANGED",payload:{state:n.status}}),this.handlePopupConnection()}e.onMessage.addListener(async n=>{const t=await this.handleMessage(n,e.sender,()=>{});t&&e.postMessage(t)})}async handleMessage(e,n,t){var r;console.log("Background received message:",e.type);try{switch(e.type){case"CREATE_ROOM":return await this.createRoom((r=e.payload)==null?void 0:r.roomId);case"JOIN_ROOM":return await this.joinRoom(e.payload.roomId);case"SEND_MESSAGE":return await this.sendMessage(e.payload.text);case"GET_MESSAGES":return await this.getMessages();case"GET_SESSIONS":return await this.getSessions();case"DELETE_SESSION":return await this.deleteSessionById(e.payload.roomId);case"LEAVE_ROOM":return await this.leaveRoom();case"SET_TYPING":return await this.setTyping(e.payload.isTyping);case"GET_CONNECTION_STATUS":return this.getConnectionStatus();case"GET_RTC_CONNECTION_STATE":return this.getRTCConnectionState();case"GET_PENDING_MESSAGES":return this.getPendingMessages();case"SAVE_INCOMING_MESSAGE":return await this.saveIncomingMessage(e.payload);default:return console.warn("Unknown message type:",e.type),{error:"Unknown message type"}}}catch(a){return console.error("Error handling message:",a),{error:a instanceof Error?a.message:"Unknown error"}}}async createRoom(e){try{const n="wss://crocro.onrender.com";this.signalingClient=new _(n),await this.signalingClient.connect();const t=await this.signalingClient.createRoom(e);return this.currentRoomId=t,this.isRoomInitiator=!0,await this.initializeSignaling(),await this.initializeRTC(),await this.storage.saveSession({roomId:t,createdAt:Date.now(),type:"creator"}),{roomId:t}}catch(n){return console.error("Failed to create room:",n),{error:n instanceof Error?n.message:"Failed to create room"}}}async joinRoom(e){try{const n="wss://crocro.onrender.com";return this.signalingClient=new _(n),await this.signalingClient.connect(),await this.signalingClient.joinRoom(e),this.currentRoomId=e,this.isRoomInitiator=!1,await this.initializeSignaling(),await this.initializeRTC(),await this.storage.saveSession({roomId:e,createdAt:Date.now(),type:"joiner"}),{success:!0}}catch(n){return console.error("Failed to join room:",n),{error:n instanceof Error?n.message:"Failed to join room"}}}async initializeSignaling(){!this.signalingClient||!this.currentRoomId||(this.signalingClient.onSignal=e=>{var n;console.log("Background received signaling message:",e.type),e.type==="peer-joined"&&typeof RTCPeerConnection>"u"&&(console.log("Peer joined, WebRTC not available, using relay-only mode"),this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")),e.type==="room-joined"&&!this.isRoomInitiator&&typeof RTCPeerConnection>"u"&&(console.log("Joined room successfully, WebRTC not available, using relay-only mode"),e.hasPeer||((n=e.peers)==null?void 0:n.length)>1?(console.log("Room already has peer, marking as connected via relay"),this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")):(console.log("Room empty, waiting for peer to join"),this.notifyConnectionStateChange("connecting"))),e.type==="room-created"&&this.isRoomInitiator&&typeof RTCPeerConnection>"u"&&(console.log("Room created successfully, WebRTC not available, using relay-only mode (waiting for peer)"),this.notifyConnectionStateChange("connecting")),this.handleRTCSignal(e)},this.signalingClient.onMessage=async e=>{console.log("Background received relay message:",e),await this.handleIncomingMessage(e)},console.log("Signaling setup complete, waiting for peer connection..."))}async initializeRTC(){if(typeof RTCPeerConnection>"u"){console.log("WebRTC APIs not available in background service worker, using relay-only mode"),this.rtcManager=null;return}this.rtcManager&&(console.log("Cleaning up existing RTC manager"),this.rtcManager.close(),this.rtcManager=null);try{const e=this.getRTCConfig();this.rtcManager=new L(e),this.rtcManager.onMessage=n=>{this.handleIncomingRTCMessage(n)},this.rtcManager.onConnectionStateChange=n=>{console.log("Background RTC connection state changed:",n),this.notifyConnectionStateChange(n),n==="connected"&&this.pendingMessages.length>0&&this.sendQueuedMessages()},this.rtcManager.onSignal=n=>{this.signalingClient&&this.signalingClient.sendSignal(n)},this.isRoomInitiator&&(console.log("Initializing WebRTC as initiator (creator)"),await this.rtcManager.initialize(!0)),console.log("Background RTC manager initialized")}catch(e){console.error("Failed to initialize WebRTC in background, falling back to relay-only:",e),this.rtcManager=null}}handlePopupConnection(){if(this.pendingMessages.length>0&&this.popupPort){console.log("Sending",this.pendingMessages.length,"pending messages to popup");for(const e of this.pendingMessages)this.popupPort.postMessage({type:"PENDING_MESSAGE",payload:e});this.pendingMessages=[]}}async handleRTCSignal(e){var n;if(console.log("Background handling RTC signal:",e.type),typeof RTCPeerConnection>"u"||!this.rtcManager){console.log("WebRTC not available, skipping signal handling:",e.type),e.type==="peer-joined"?(this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")):e.type==="peer-left"&&(this.isRelayConnected=!1,this.notifyConnectionStateChange("connecting"));return}if(e.type==="peer-joined")console.log("Peer joined, immediately activating relay mode and attempting WebRTC"),this.isRelayConnected||(console.log("Second participant connected, activating relay mode"),this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")),this.isRoomInitiator&&this.rtcManager&&setTimeout(()=>{this.rtcManager&&(console.log("Initializing WebRTC as initiator:",this.isRoomInitiator),this.rtcManager.initialize(this.isRoomInitiator))},100);else if(e.type==="peer-reconnected")console.log("Peer reconnected, signal data:",e),(e.isInitiator||((n=e.data)==null?void 0:n.isInitiator))===!1&&this.isRoomInitiator&&this.rtcManager&&(console.log("Joiner reconnected, re-initializing WebRTC as initiator"),setTimeout(()=>{this.rtcManager&&this.rtcManager.initialize(this.isRoomInitiator)},100));else if(e.type==="offer"){if(console.log("Received offer signal, rtcManager exists:",!!this.rtcManager),this.rtcManager||(console.log("Creating new RTCManager for joiner"),await this.initializeRTC()),this.rtcManager){const t=this.rtcManager.getConnectionState();console.log("RTCManager state:",t),(t==="new"||t==="closed"||t==="disconnected")&&(console.log("Re-initializing RTCManager as joiner"),await this.rtcManager.initialize(!1)),await this.rtcManager.handleSignal(e)}}else this.rtcManager&&(console.log("Forwarding signal to RTC manager:",e.type),this.rtcManager.handleSignal(e))}getRTCConfig(){const e=JSON.parse('["stun:stun.l.google.com:19302"]'),n=JSON.parse("[]");return{stunServers:e,turnServers:n,turnUsername:"",turnPassword:""}}async handleIncomingRTCMessage(e){if(!this.currentRoomId)return;const n={...e,from:"peer",roomId:this.currentRoomId};await this.storage.saveMessage(n),this.popupPort?this.popupPort.postMessage({type:"RTC_MESSAGE_RECEIVED",payload:n}):this.pendingMessages.push(n),this.notifyMessageReceived(n)}async sendQueuedMessages(){!this.rtcManager||!this.rtcManager.isConnected()||console.log("Sending queued messages via WebRTC")}getRTCConnectionState(){var e,n,t;return{connected:((e=this.rtcManager)==null?void 0:e.isConnected())||!1,connectionState:((n=this.rtcManager)==null?void 0:n.getConnectionState())||"disconnected",dataChannelState:((t=this.rtcManager)==null?void 0:t.getDataChannelState())||null}}getPendingMessages(){return{messages:this.pendingMessages}}async getSessions(){try{return{sessions:await this.storage.getAllSessions()}}catch(e){return console.error("Error getting sessions:",e),{sessions:[]}}}async deleteSessionById(e){try{return await this.storage.deleteSession(e),{success:!0}}catch(n){return console.error("Error deleting session:",n),{success:!1}}}async saveIncomingMessage(e){if(!this.currentRoomId)return{success:!1};try{const n={...e,from:"peer",roomId:this.currentRoomId};return await this.storage.saveMessage(n),this.notifyMessageReceived(n),{success:!0}}catch(n){return console.error("Error saving incoming message:",n),{success:!1}}}async sendMessage(e){if(!this.currentRoomId)return{error:"Not connected to a room"};try{const n={id:crypto.randomUUID(),roomId:this.currentRoomId,text:e,timestamp:Date.now(),from:"self"};await this.storage.saveMessage(n);let t=!1;return this.rtcManager&&this.rtcManager.isConnected()&&(await this.rtcManager.sendMessage(n)?(t=!0,console.log("Message sent via WebRTC")):console.log("WebRTC send failed, falling back to relay")),t||(console.log("Sending message via relay (WebRTC not available or failed)"),this.signalingClient&&(this.signalingClient.sendRelayMessage(n),t=!0,this.isRelayConnected||(console.log("Successfully sent relay message, marking relay connection as active"),this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")))),this.notifyMessageSent(n),{success:!0}}catch(n){return console.error("Error sending message:",n),{error:n instanceof Error?n.message:"Failed to send message"}}}async handleIncomingMessage(e){if(!this.currentRoomId)return;const n={...e,from:"peer",roomId:this.currentRoomId};await this.storage.saveMessage(n),this.isRelayConnected||(console.log("Received relay message, marking relay connection as active"),this.isRelayConnected=!0,this.notifyConnectionStateChange("connected")),this.popupPort&&this.popupPort.postMessage({type:"RELAY_MESSAGE_RECEIVED",payload:n}),this.notifyMessageReceived(n)}async getMessages(){return this.currentRoomId?{messages:await this.storage.getMessages(this.currentRoomId)}:{messages:[]}}async leaveRoom(){return this.rtcManager&&(this.rtcManager.close(),this.rtcManager=null),this.signalingClient&&(this.signalingClient.disconnect(),this.signalingClient=null),this.currentRoomId=null,this.isRoomInitiator=!1,this.isRelayConnected=!1,this.pendingMessages=[],{success:!0}}async setTyping(e){return this.rtcManager&&this.rtcManager.isConnected()&&await this.rtcManager.sendTypingIndicator(e),{success:!0}}getConnectionStatus(){var l,m,f;const e=((l=this.signalingClient)==null?void 0:l.getConnectionState())==="connected",n=((m=this.rtcManager)==null?void 0:m.isConnected())||!1,t=((f=this.rtcManager)==null?void 0:f.getConnectionState())||"disconnected",r=n||this.isRelayConnected,a=n?t:this.isRelayConnected?"connected":"connecting";let s="disconnected";return r?s="connected":e&&this.currentRoomId&&(s="connecting"),{connected:r,roomId:this.currentRoomId,connectionState:a,signaling:e,status:s,isInitiator:this.isRoomInitiator}}notifyMessageSent(e){this.broadcastToUI("MESSAGE_SENT",e)}notifyMessageReceived(e){this.broadcastToUI("MESSAGE_RECEIVED",e)}notifyConnectionStateChange(e){this.broadcastToUI("CONNECTION_STATE_CHANGED",{state:e}),this.popupPort&&this.popupPort.postMessage({type:"CONNECTION_STATE_CHANGED",payload:{state:e}})}async broadcastToUI(e,n){try{const t=await T.tabs.query({active:!0});for(const r of t)r.id&&T.tabs.sendMessage(r.id,{type:e,payload:n}).catch(()=>{})}catch(t){console.warn("Failed to broadcast to UI:",t)}}}new $})();
